{"version":3,"file":"components/carousel-cov-touch.js","sources":["webpack:///./components/carousel/cov-touch.js"],"sourcesContent":["const TOUCH_EVENT_MAP = {\r\n  'touchstart': 1,\r\n  'touchmove': 1,\r\n  'touchend': 1\r\n}\r\n\r\nconst MOUSE_EVENT_MAP = {\r\n  'mousedown': 1,\r\n  'mousemove': 1,\r\n  'mouseup': 1\r\n}\r\n\r\nconst _ = {\r\n  on (el, type, func) {\r\n    el.addEventListener(type, func, false)\r\n  },\r\n  off (el, type, func) {\r\n    el.removeEventListener(type, func, false)\r\n  }\r\n}\r\n\r\nclass CovTouch {\r\n  constructor ({ el }) {\r\n    this._hasTouch = ('ontouchstart' in window)\r\n    this.$el = el\r\n    this.init()\r\n    this.touch = {\r\n      start: null,\r\n      end: null\r\n    }\r\n    this.state = {\r\n      swiping: false,\r\n      global: false\r\n    }\r\n    this.queue = {\r\n      'swiping': [],\r\n      'swiped': [],\r\n      'swipe-left': [],\r\n      'swipe-right': [],\r\n      'swipe-up': [],\r\n      'swipe-down': []\r\n    }\r\n  }\r\n\r\n  init () {\r\n    if (this._hasTouch) {\r\n      _.on(this.$el, 'touchstart', this.touchStart.bind(this))\r\n      _.on(window, 'touchmove', this.touchMove.bind(this))\r\n      _.on(window, 'touchend', this.touchEnd.bind(this))\r\n      _.on(window, 'touchcancel', this.touchCancel.bind(this))\r\n    } else {\r\n      _.on(this.$el, 'mousedown', this.touchStart.bind(this))\r\n      _.on(window, 'mousemove', this.touchMove.bind(this))\r\n      _.on(window, 'mouseup', this.touchEnd.bind(this))\r\n    }\r\n  }\r\n\r\n  destroy () {\r\n    if (this.$el) {\r\n      _.off(this.$el, 'touchstart', this.touchStart.bind(this))\r\n      _.off(this.$el, 'mousedown', this.touchStart.bind(this))\r\n    }\r\n\r\n    _.off(window, 'touchmove', this.touchMove.bind(this))\r\n    _.off(window, 'touchend', this.touchEnd.bind(this))\r\n    _.off(window, 'touchcancel', this.touchCancel.bind(this))\r\n    _.off(window, 'mousemove', this.touchMove.bind(this))\r\n    _.off(window, 'mouseup', this.touchEnd.bind(this))\r\n\r\n    this.queue = {\r\n      'swiping': [],\r\n      'swiped': [],\r\n      'swipe-left': [],\r\n      'swipe-right': [],\r\n      'swipe-up': [],\r\n      'swipe-down': []\r\n    }\r\n  }\r\n\r\n  setGlobal () {\r\n    this.state.global = true\r\n  }\r\n\r\n  cancelGlobal () {\r\n    this.state.global = false\r\n  }\r\n\r\n  listen (type, $el, func) {\r\n    let rect\r\n    if (!$el) {\r\n      rect = null\r\n    } else {\r\n      let tmp = $el.getBoundingClientRect()\r\n      rect = {\r\n        x: tmp.left,\r\n        y: tmp.top,\r\n        width: tmp.width,\r\n        height: tmp.height\r\n      }\r\n    }\r\n\r\n    let token = Math.random() * 9999 + type\r\n    this.queue[type].push({\r\n      $el: $el,\r\n      token: token,\r\n      func: func,\r\n      rect: rect\r\n    })\r\n  }\r\n\r\n  leave (type, token) {\r\n    if (!this.queue[type]) return false\r\n    for (let i = 0, len = this.queue[type].length; i < len; i++) {\r\n      if (this.queue[type].token === token) {\r\n        this.queue[type].splice(i - 1, 1)\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  update () {\r\n    let keys = Object.keys(this.queue)\r\n    let tmp\r\n    for (let key of keys) {\r\n      this.queue[key].forEach(item => {\r\n        if (item.$el) {\r\n          tmp = item.$el.getBoundingClientRect()\r\n          item.rect = {\r\n            x: tmp.left,\r\n            y: tmp.top,\r\n            width: tmp.width,\r\n            height: tmp.height\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  clear () {\r\n    let keys = Object.keys(this.queue)\r\n    for (let key of keys) {\r\n      this.queue[key].length = 0\r\n    }\r\n  }\r\n\r\n  notice (type, rect) {\r\n    let rectTmp = {}\r\n    let once = true\r\n    let tmpFunc = null\r\n    for (let i = 0, len = this.queue[type].length; i < len; i++) {\r\n      rectTmp = this.queue[type][i].rect\r\n      if (!rectTmp) {\r\n        tmpFunc = this.queue[type][i].func\r\n      } else {\r\n        if (this.rectIn(rect, rectTmp) && !this.state.global) {\r\n          this.queue[type][i].func(this.touch.start, this.touch.end)\r\n          once = false\r\n        }\r\n      }\r\n    }\r\n    if (once && tmpFunc) {\r\n      tmpFunc(this.touch.start, this.touch.end)\r\n    }\r\n  }\r\n\r\n  rectIn (small, big) {\r\n    if (small.x > big.x &&\r\n      small.x + small.width < big.x + big.width &&\r\n      small.y > big.y &&\r\n      small.y + small.height < big.y + big.height\r\n    ) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  getRect (dot1, dot2) {\r\n    let rect = {}\r\n\r\n    if (dot1.x < dot2.x) {\r\n      rect.x = dot1.x\r\n      rect.width = dot2.x - dot1.x\r\n    } else {\r\n      rect.x = dot2.x\r\n      rect.width = dot1.x - dot2.x\r\n    }\r\n\r\n    if (dot1.y < dot2.y) {\r\n      rect.y = dot1.y\r\n      rect.height = dot2.y - dot1.y\r\n    } else {\r\n      rect.y = dot2.y\r\n      rect.height = dot1.y - dot2.y\r\n    }\r\n    return rect\r\n  }\r\n\r\n  getPosition (e) {\r\n    if (TOUCH_EVENT_MAP[e.type]) {\r\n      let poss = []\r\n      const len = e.touches.length\r\n      for (let i = 0; i < len; i++) {\r\n        poss.push({\r\n          x: e.touches[i].pageX,\r\n          y: e.touches[i].pageY\r\n        })\r\n      }\r\n      return poss\r\n    } else if (MOUSE_EVENT_MAP[e.type]) {\r\n      return [{\r\n        x: e.pageX,\r\n        y: e.pageY\r\n      }]\r\n    }\r\n  }\r\n\r\n  getDistance (dot1, dot2) {\r\n    return Math.sqrt(Math.pow(dot1.x - dot2.x, 2) + Math.pow(dot1.y - dot2.y, 2))\r\n  }\r\n\r\n  getAngle (dot1, dot2) {\r\n    return Math.atan2(dot2.y - dot1.y, dot2.x - dot1.x) * 180 / Math.PI\r\n  }\r\n\r\n  touchStart (e) {\r\n    this.state.swiping = true\r\n    this.touch.start = this.getPosition(e)[0]\r\n  }\r\n\r\n  touchMove (e) {\r\n    if (!this.touch.start) return\r\n    this.touch.end = this.getPosition(e)[0]\r\n    this.notice('swiping', this.getRect(this.touch.end, this.touch.start))\r\n  }\r\n\r\n  touchEnd (e) {\r\n    if (!this.touch.start) return\r\n    if (e.type === 'mouseup') {\r\n      this.touch.end = this.getPosition(e)[0]\r\n    }\r\n    let angle = this.getAngle(this.touch.end, this.touch.start)\r\n    if (angle > -45 && angle < 45) {\r\n      this.notice('swipe-left', this.getRect(this.touch.end, this.touch.start))\r\n    }\r\n    if (angle < -135 || angle > 135) {\r\n      this.notice('swipe-right', this.getRect(this.touch.end, this.touch.start))\r\n    }\r\n    if (angle > 45 && angle < 135) {\r\n      this.notice('swipe-up', this.getRect(this.touch.end, this.touch.start))\r\n    }\r\n    if (angle < -45 && angle > -135) {\r\n      this.notice('swipe-down', this.getRect(this.touch.end, this.touch.start))\r\n    }\r\n    this.notice('swiped', this.getRect(this.touch.end, this.touch.start))\r\n    this.state.swiping = false\r\n    this.touch.start = null\r\n  }\r\n\r\n  touchCancel (e) {\r\n    e.preventDefault()\r\n    console.log(e)\r\n  }\r\n}\r\n\r\nexport default CovTouch\r\n"],"mappings":";;;;;;;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAPA;AACA;AAQA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlPA;AACA;AAmPA;;;;A","sourceRoot":""}